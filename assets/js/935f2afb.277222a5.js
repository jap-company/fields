"use strict";(self.webpackChunkfields_docs=self.webpackChunkfields_docs||[]).push([[53],{1109:function(i){i.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"link","label":"Overview","href":"/fields/docs/overview","docId":"overview"},{"type":"link","label":"ValidationModule","href":"/fields/docs/validation-module","docId":"validation-module"},{"type":"category","label":"Data Types","items":[{"type":"link","label":"Field","href":"/fields/docs/field","docId":"field"},{"type":"link","label":"FieldPath","href":"/fields/docs/fieldpath","docId":"fieldpath"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Type Classes","items":[{"type":"link","label":"ValidationResult","href":"/fields/docs/validation-result","docId":"validation-result"},{"type":"link","label":"ValidationEffect","href":"/fields/docs/validation-effect","docId":"validation-effect"},{"type":"link","label":"ValidationPolicy","href":"/fields/docs/validation-policy","docId":"validation-policy"},{"type":"link","label":"FailWith","href":"/fields/docs/fail-with","docId":"fail-with"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Syntax","href":"/fields/docs/validation-syntax","docId":"validation-syntax"},{"type":"link","label":"Goals of the project","href":"/fields/docs/goals","docId":"goals"},{"type":"link","label":"Contributing","href":"/fields/docs/contributing","docId":"contributing"}]},"docs":{"contributing":{"id":"contributing","title":"Contributing","description":"All suggestions welcome :)!","sidebar":"docs"},"fail-with":{"id":"fail-with","title":"FailWith","description":"Fields has capability for user to use his own error type and this raises question how should library know for standart validation which error to use? FailWith* typeclasses gives this library ability to fail with specific errors.","sidebar":"docs"},"field":{"id":"field","title":"Field","description":"Library is called Fields solely because it is built around Field data type.","sidebar":"docs"},"fieldpath":{"id":"fieldpath","title":"FieldPath","description":"Stores Field path, that at the end of the day is used to know where some ValidationError was raised.","sidebar":"docs"},"goals":{"id":"goals","title":"Goals of the project","description":"- Easier validation","sidebar":"docs"},"overview":{"id":"overview","title":"Overview","description":"Fields is a zero-dependency Scala validation library.","sidebar":"docs"},"traits":{"id":"traits","title":"traits","description":"- Configurable. Choose any Effect, ValidationResult or Error types."},"validation":{"id":"validation","title":"Validation","description":"Syntax"},"validation-effect":{"id":"validation-effect","title":"ValidationEffect","description":"Defines Monad/Defer like capabilities for your F[_].","sidebar":"docs"},"validation-module":{"id":"validation-module","title":"ValidationModule","description":"All syntax comes from ValidationModule and if default ones do not suit your needs you can define custom.","sidebar":"docs"},"validation-policy":{"id":"validation-policy","title":"ValidationPolicy","description":"Encapsulates Field validation logic. Also there is ValidationPolicyBuilder which provides convenient syntax to define Field validation logic","sidebar":"docs"},"validation-result":{"id":"validation-result","title":"ValidationResult","description":"Defines ValidationResult capabilities for VR[_], so that Fields know how to use it when validating.","sidebar":"docs"},"validation-syntax":{"id":"validation-syntax","title":"Syntax","description":"Here is complete list of predefined validation syntax.","sidebar":"docs"}}}')}}]);