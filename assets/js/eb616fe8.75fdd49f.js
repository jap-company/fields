"use strict";(self.webpackChunkfields_docs=self.webpackChunkfields_docs||[]).push([[642],{3905:(e,a,n)=>{n.d(a,{Zo:()=>c,kt:()=>h});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=t.createContext({}),d=function(e){var a=t.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},c=function(e){var a=d(e.components);return t.createElement(o.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},p=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),h=r,m=p["".concat(o,".").concat(h)]||p[h]||u[h]||i;return n?t.createElement(m,l(l({ref:a},c),{},{components:n})):t.createElement(m,l({ref:a},c))}));function h(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=p;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var d=2;d<i;d++)l[d]=n[d];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}p.displayName="MDXCreateElement"},191:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var t=n(7462),r=(n(7294),n(3905));const i={},l="Syntax",s={unversionedId:"validation-syntax",id:"validation-syntax",title:"Syntax",description:"Here is complete list of predefined validation syntax.",source:"@site/../fields-docs/target/mdoc/validation-syntax.md",sourceDirName:".",slug:"/validation-syntax",permalink:"/fields/docs/validation-syntax",draft:!1,editUrl:"https://github.com/jap-company/fields/tree/master/docs/validation-syntax.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Module",permalink:"/fields/docs/validation-module"},next:{title:"Error",permalink:"/fields/docs/validation-error"}},o={},d=[{value:"Generic",id:"generic",level:2},{value:"Boolean",id:"boolean",level:2},{value:"Ordering",id:"ordering",level:2},{value:"Option",id:"option",level:2},{value:"String",id:"string",level:2},{value:"Iterable",id:"iterable",level:2},{value:"Map",id:"map",level:2},{value:"Effectful",id:"effectful",level:2}],c={toc:d};function u(e){let{components:a,...n}=e;return(0,r.kt)("wrapper",(0,t.Z)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"Here is complete list of predefined validation syntax."),(0,r.kt)("h2",{id:"generic"},"Generic"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import jap.fields._\nimport jap.fields.DefaultAccumulateVM._\nimport jap.fields.FieldPathConversions._\n\nval field: Field[Int] = Field("1", 1)\n// field: Field[Int] = Field(path = FieldPath(parts = List(Path(value = "1"))), value = 1)\nfield.ensure(_ == 3, _.failInvalid)\n// res0: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Invalid(path = FieldPath(parts = List(Path(value = "1")))))\n// )\nfield.assert(_ == 3, _.invalidError)\n// res1: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Invalid(path = FieldPath(parts = List(Path(value = "1")))))\n// )\nfield.check(f => if(false) f.failMessage("A") else f.failMessage("B"))\n// res2: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(path = FieldPath(parts = List(Path(value = "1"))), error = "B", message = None)\n//   )\n// )\nfield equalTo 2\n// res3: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List(Path(value = "1"))), compared = "2"))\n// )\nfield notEqualTo 1\n// res4: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NotEqual(path = FieldPath(parts = List(Path(value = "1"))), compared = "1"))\n// )\nfield equalTo Field("2", 2)\n// res5: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List(Path(value = "1"))), compared = ".2"))\n// )\nfield notEqualTo Field("1", 1)\n// res6: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NotEqual(path = FieldPath(parts = List(Path(value = "1"))), compared = ".1"))\n// )\nfield in List(2, 3)\n// res7: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(OneOf(path = FieldPath(parts = List(Path(value = "1"))), variants = List("2", "3")))\n// )\nfield.all(_ === 2, _ !== 1)\n// res8: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Equal(path = FieldPath(parts = List(Path(value = "1"))), compared = "2"),\n//     NotEqual(path = FieldPath(parts = List(Path(value = "1"))), compared = "1")\n//   )\n// )\nfield.any(_ === 2, _ !== 3)\n// res9: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nfield.when(false)(_ !== field.value)\n// res10: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nfield.unless(true)(_ !== field.value)\n// res11: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nimplicit val policy: Policy[Int] = _ < 0\n// policy: ValidationPolicy[Int, Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = <function1>\nfield.validate\n// res12: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Less(path = FieldPath(parts = List(Path(value = "1"))), compared = "0"))\n// )\n\nsealed trait ABC\ncase class A(a: Int) extends ABC\ncase class B() extends ABC\ncase class C() extends ABC\n\nField[ABC](A(-1)).whenType[A](_.check(_.failMessage("A")))\n// res13: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Message(path = FieldPath(parts = List()), error = "A", message = None))\n// )\nField[ABC](A(-1)).whenType[A](_.sub(_.a) > 0)\n// res14: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Greater(path = FieldPath(parts = List(Path(value = "a"))), compared = "0"))\n// )\nField[ABC](A(-1)).whenType[B](_.check(_.failMessage("B")))\n// res15: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nField[ABC](A(-1)).whenType[C](_.check(_.failMessage("B")))\n// res16: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\n')),(0,r.kt)("h2",{id:"boolean"},"Boolean"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Field("false", false).isTrue\n// res17: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List(Path(value = "false"))), compared = "true"))\n// )\nField("true", true).isFalse\n// res18: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List(Path(value = "true"))), compared = "false"))\n// )\n')),(0,r.kt)("h2",{id:"ordering"},"Ordering"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import java.time.LocalDateTime\nval now = LocalDateTime.now\n// now: LocalDateTime = 2022-08-09T21:25:08.553\nval nowF = Field.from(now)\n// nowF: Field[LocalDateTime] = Field(\n//   path = FieldPath(parts = List(Path(value = "now"))),\n//   value = 2022-08-09T21:25:08.553\n// )\nval tomorrow = now.plusDays(1)\n// tomorrow: LocalDateTime = 2022-08-10T21:25:08.553\nval yesterday = now.minusDays(1)\n// yesterday: LocalDateTime = 2022-08-08T21:25:08.553\n\nnowF.isBetween(tomorrow, yesterday)\n// res19: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     GreaterEqual(\n//       path = FieldPath(parts = List(Path(value = "now"))),\n//       compared = "2022-08-10T21:25:08.553"\n//     ),\n//     LessEqual(\n//       path = FieldPath(parts = List(Path(value = "now"))),\n//       compared = "2022-08-08T21:25:08.553"\n//     )\n//   )\n// )\nnowF < yesterday\n// res20: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Less(path = FieldPath(parts = List(Path(value = "now"))), compared = "2022-08-08T21:25:08.553")\n//   )\n// )\nnowF <= yesterday\n// res21: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     LessEqual(\n//       path = FieldPath(parts = List(Path(value = "now"))),\n//       compared = "2022-08-08T21:25:08.553"\n//     )\n//   )\n// )\nnowF >= tomorrow\n// res22: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     GreaterEqual(\n//       path = FieldPath(parts = List(Path(value = "now"))),\n//       compared = "2022-08-10T21:25:08.553"\n//     )\n//   )\n// )\nnowF > tomorrow\n// res23: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(\n//       path = FieldPath(parts = List(Path(value = "now"))),\n//       compared = "2022-08-10T21:25:08.553"\n//     )\n//   )\n// )\n')),(0,r.kt)("h2",{id:"option"},"Option"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Field(None).isDefined\n// res24: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Empty(path = FieldPath(parts = List())))\n// )\nval someF: Field[Option[Int]] = Field("a", Some(5))\n// someF: Field[Option[Int]] = Field(\n//   path = FieldPath(parts = List(Path(value = "a"))),\n//   value = Some(value = 5)\n// )\nsomeF.isEmpty\n// res25: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List(Path(value = "a")))))\n// )\nsomeF.some(_ > 10)\n// res26: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Greater(path = FieldPath(parts = List(Path(value = "a"))), compared = "10"))\n// )\n\nsomeOrValid {\n    for {\n        option <- someF.option\n        other <- Field("b", Some(2)).option\n    } yield option < other\n}\n// res27: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Less(path = FieldPath(parts = List(Path(value = "a"))), compared = ".b"))\n// )\n')),(0,r.kt)("h2",{id:"string"},"String"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val stringF: Field[String] = Field("Ann")\n// stringF: Field[String] = Field(path = FieldPath(parts = List()), value = "Ann")\nstringF.startsWith("sca")\n// res28: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/starts_with",\n//       message = Some(value = "must start with sca")\n//     )\n//   )\n// )\nstringF.endsWith("la")\n// res29: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/ends_with",\n//       message = Some(value = "must end with la")\n//     )\n//   )\n// )\nField("").nonEmpty\n// res30: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List())))\n// )\nField("").nonBlank\n// res31: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List())))\n// )\nstringF.minSize(5)\n// res32: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MinSize(path = FieldPath(parts = List()), size = 5))\n// )\nstringF.maxSize(1)\n// res33: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MaxSize(path = FieldPath(parts = List()), size = 1))\n// )\nstringF.blank\n// res34: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Empty(path = FieldPath(parts = List())))\n// )\nstringF.matchesRegex("scala".r)\n// res35: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/match",\n//       message = Some(value = "must match scala")\n//     )\n//   )\n// )\nstringF.matches("scala")\n// res36: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/match",\n//       message = Some(value = "must match scala")\n//     )\n//   )\n// )\n')),(0,r.kt)("h2",{id:"iterable"},"Iterable"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val listF: Field[List[Int]] = Field(List(1, 12))\n// listF: Field[List[Int]] = Field(path = FieldPath(parts = List()), value = List(1, 12))\nlistF.each(_ > 10)\n// res37: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Greater(path = FieldPath(parts = List(Index(value = 0))), compared = "10"))\n// )\nlistF.any(_ === 10)\n// res38: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Equal(path = FieldPath(parts = List(Index(value = 1))), compared = "10"),\n//     Equal(path = FieldPath(parts = List(Index(value = 0))), compared = "10")\n//   )\n// )\nField(List()).nonEmpty\n// res39: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List())))\n// )\nlistF.minSize(3)\n// res40: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MinSize(path = FieldPath(parts = List()), size = 3))\n// )\nlistF.maxSize(1)\n// res41: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MaxSize(path = FieldPath(parts = List()), size = 1))\n// )\n')),(0,r.kt)("h2",{id:"map"},"Map"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val mapF: Field[Map[String, Int]] = Field(Map("" -> 2, "2" -> 2))\n// mapF: Field[Map[String, Int]] = Field(\n//   path = FieldPath(parts = List()),\n//   value = Map("" -> 2, "2" -> 2)\n// )\nmapF.minSize(4)\n// res42: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MinSize(path = FieldPath(parts = List()), size = 4))\n// )\nmapF.maxSize(1)\n// res43: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MaxSize(path = FieldPath(parts = List()), size = 1))\n// )\nmapF.each(_.second > 4)\n// res44: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List(Path(value = ""))), compared = "4"),\n//     Greater(path = FieldPath(parts = List(Path(value = "2"))), compared = "4")\n//   )\n// )\nmapF.eachKey(_.nonEmpty)\n// res45: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List(Path(value = "")))))\n// )\nmapF.eachValue(_ > 4)\n// res46: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List(Path(value = ""))), compared = "4"),\n//     Greater(path = FieldPath(parts = List(Path(value = "2"))), compared = "4")\n//   )\n// )\nmapF.any(_.second > 4)\n// res47: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List(Path(value = "2"))), compared = "4"),\n//     Greater(path = FieldPath(parts = List(Path(value = ""))), compared = "4")\n//   )\n// )\nmapF.anyKey(_ === "4")\n// res48: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Equal(path = FieldPath(parts = List(Path(value = "2"))), compared = "4"),\n//     Equal(path = FieldPath(parts = List(Path(value = ""))), compared = "4")\n//   )\n// )\nmapF.anyValue(_ > 4)\n// res49: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List(Path(value = "2"))), compared = "4"),\n//     Greater(path = FieldPath(parts = List(Path(value = ""))), compared = "4")\n//   )\n// )\n')),(0,r.kt)("h2",{id:"effectful"},"Effectful"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import jap.fields._\nimport jap.fields.ZIOInterop._\nimport jap.fields.fail._\nimport jap.fields.error._\nimport zio._\n\nobject Validation extends AccumulateVM[Task, ValidationError] with CanFailWithValidationError\nimport Validation._\n\ndef unsafeRun[A](task: Task[A]) = Runtime.global.unsafeRun(task)\ndef isPositiveApi(number: Int): zio.Task[Boolean] = zio.UIO(number > 0)\n\nval field = Field(FieldPath.fromPath("size"), -1)\n// field: Field[Int] = Field(path = FieldPath(parts = List(Path(value = "size"))), value = -1)\nunsafeRun(field.ensureF(isPositiveApi, _.failMessage("API: NOT POSITIVE")).effect)\n// res51: Accumulate[ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List(Path(value = "size"))),\n//       error = "API: NOT POSITIVE",\n//       message = None\n//     )\n//   )\n// )\nunsafeRun(field.assertF(isPositiveApi, _.messageError("API: NOT POSITIVE")).effect)\n// res52: Accumulate[ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List(Path(value = "size"))),\n//       error = "API: NOT POSITIVE",\n//       message = None\n//     )\n//   )\n// )\n')))}u.isMDXComponent=!0}}]);