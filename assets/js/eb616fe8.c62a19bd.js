"use strict";(self.webpackChunkfields_docs=self.webpackChunkfields_docs||[]).push([[642],{3905:(e,n,a)=>{a.d(n,{Zo:()=>c,kt:()=>m});var t=a(7294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=t.createContext({}),d=function(e){var n=t.useContext(o),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},c=function(e){var n=d(e.components);return t.createElement(o.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(a),m=r,h=u["".concat(o,".").concat(m)]||u[m]||p[m]||i;return a?t.createElement(h,l(l({ref:n},c),{},{components:a})):t.createElement(h,l({ref:n},c))}));function m(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=u;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var d=2;d<i;d++)l[d]=a[d];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},191:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var t=a(7462),r=(a(7294),a(3905));const i={},l="Syntax",s={unversionedId:"validation-syntax",id:"validation-syntax",title:"Syntax",description:"Here is complete list of predefined validation syntax.",source:"@site/../fields-docs/target/mdoc/validation-syntax.md",sourceDirName:".",slug:"/validation-syntax",permalink:"/fields/docs/validation-syntax",draft:!1,editUrl:"https://github.com/jap-company/fields/tree/master/docs/validation-syntax.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Module",permalink:"/fields/docs/validation-module"},next:{title:"Error",permalink:"/fields/docs/validation-error"}},o={},d=[{value:"Generic",id:"generic",level:2},{value:"Boolean",id:"boolean",level:2},{value:"Ordering",id:"ordering",level:2},{value:"Option",id:"option",level:2},{value:"String",id:"string",level:2},{value:"Iterable",id:"iterable",level:2},{value:"Map",id:"map",level:2},{value:"Effectful",id:"effectful",level:2}],c={toc:d};function p(e){let{components:n,...a}=e;return(0,r.kt)("wrapper",(0,t.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"Here is complete list of predefined validation syntax."),(0,r.kt)("h2",{id:"generic"},"Generic"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import jap.fields._\nimport jap.fields.DefaultAccumulateVM._\nimport jap.fields.FieldPathConversions._\n\nval field: Field[Int] = Field("1", 1)\n// field: Field[Int] = Field(path = FieldPath(parts = List("1")), value = 1)\nfield.ensure(_ == 3, _.failInvalid)\n// res0: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Invalid(path = FieldPath(parts = List("1"))))\n// )\nfield.assert(_ == 3, _.invalidError)\n// res1: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Invalid(path = FieldPath(parts = List("1"))))\n// )\nfield.check(f => if(false) f.failMessage("A") else f.failMessage("B"))\n// res2: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Message(path = FieldPath(parts = List("1")), error = "B", message = None))\n// )\nfield equalTo 2\n// res3: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List("1")), compared = "2"))\n// )\nfield notEqualTo 1\n// res4: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NotEqual(path = FieldPath(parts = List("1")), compared = "1"))\n// )\nfield equalTo Field("2", 2)\n// res5: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List("1")), compared = "2"))\n// )\nfield notEqualTo Field("1", 1)\n// res6: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NotEqual(path = FieldPath(parts = List("1")), compared = "1"))\n// )\nfield in List(2, 3)\n// res7: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(OneOf(path = FieldPath(parts = List("1")), variants = List("2", "3")))\n// )\nfield.all(_ === 2, _ !== 1)\n// res8: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Equal(path = FieldPath(parts = List("1")), compared = "2"),\n//     NotEqual(path = FieldPath(parts = List("1")), compared = "1")\n//   )\n// )\nfield.any(_ === 2, _ !== 3)\n// res9: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nfield.when(false)(_ !== field.value)\n// res10: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nfield.unless(true)(_ !== field.value)\n// res11: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nimplicit val policy: Policy[Int] = _ < 0\n// policy: ValidationPolicy[Int, Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = <function1>\nfield.validate\n// res12: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Less(path = FieldPath(parts = List("1")), compared = "0"))\n// )\n\nsealed trait ABC\ncase class A(a: Int) extends ABC\ncase class B() extends ABC\ncase class C() extends ABC\n\nField[ABC](A(-1)).whenType[A](_.check(_.failMessage("A")))\n// res13: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Message(path = FieldPath(parts = List()), error = "A", message = None))\n// )\nField[ABC](A(-1)).whenType[A](_.sub(_.a) > 0)\n// res14: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Greater(path = FieldPath(parts = List("a")), compared = "0"))\n// )\nField[ABC](A(-1)).whenType[B](_.check(_.failMessage("B")))\n// res15: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\nField[ABC](A(-1)).whenType[C](_.check(_.failMessage("B")))\n// res16: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Valid\n')),(0,r.kt)("h2",{id:"boolean"},"Boolean"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Field("false", false).isTrue\n// res17: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List("false")), compared = "true"))\n// )\nField("true", true).isFalse\n// res18: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Equal(path = FieldPath(parts = List("true")), compared = "false"))\n// )\n')),(0,r.kt)("h2",{id:"ordering"},"Ordering"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import java.time.LocalDateTime\nval now = LocalDateTime.now\n// now: LocalDateTime = 2022-07-23T16:52:41.062\nval nowF = Field.from(now)\n// nowF: Field[LocalDateTime] = Field(\n//   path = FieldPath(parts = List("now")),\n//   value = 2022-07-23T16:52:41.062\n// )\nval tomorrow = now.plusDays(1)\n// tomorrow: LocalDateTime = 2022-07-24T16:52:41.062\nval yesterday = now.minusDays(1)\n// yesterday: LocalDateTime = 2022-07-22T16:52:41.062\n\nnowF.isBetween(tomorrow, yesterday)\n// res19: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     GreaterEqual(path = FieldPath(parts = List("now")), compared = "2022-07-24T16:52:41.062"),\n//     LessEqual(path = FieldPath(parts = List("now")), compared = "2022-07-22T16:52:41.062")\n//   )\n// )\nnowF < yesterday\n// res20: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Less(path = FieldPath(parts = List("now")), compared = "2022-07-22T16:52:41.062"))\n// )\nnowF <= yesterday\n// res21: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     LessEqual(path = FieldPath(parts = List("now")), compared = "2022-07-22T16:52:41.062")\n//   )\n// )\nnowF >= tomorrow\n// res22: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     GreaterEqual(path = FieldPath(parts = List("now")), compared = "2022-07-24T16:52:41.062")\n//   )\n// )\nnowF > tomorrow\n// res23: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List("now")), compared = "2022-07-24T16:52:41.062")\n//   )\n// )\n')),(0,r.kt)("h2",{id:"option"},"Option"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Field(None).isDefined\n// res24: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Empty(path = FieldPath(parts = List())))\n// )\nval someF: Field[Option[Int]] = Field(FieldPath("a"), Some(5))\n// someF: Field[Option[Int]] = Field(path = FieldPath(parts = List("a")), value = Some(value = 5))\nsomeF.isEmpty\n// res25: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List("a"))))\n// )\nsomeF.some(_ > 10)\n// res26: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Greater(path = FieldPath(parts = List("a")), compared = "10"))\n// )\n\nsomeOrValid {\n    for {\n        option <- someF.option\n        other <- Field(FieldPath("b"), Some(2)).option\n    } yield option < other\n}\n// res27: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Less(path = FieldPath(parts = List("a")), compared = "b"))\n// )\n')),(0,r.kt)("h2",{id:"string"},"String"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val stringF: Field[String] = Field("Ann")\n// stringF: Field[String] = Field(path = FieldPath(parts = List()), value = "Ann")\nstringF.startsWith("sca")\n// res28: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/starts_with",\n//       message = Some(value = "must start with sca")\n//     )\n//   )\n// )\nstringF.endsWith("la")\n// res29: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/ends_with",\n//       message = Some(value = "must end with la")\n//     )\n//   )\n// )\nField("").nonEmpty\n// res30: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List())))\n// )\nField("").nonBlank\n// res31: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List())))\n// )\nstringF.minSize(5)\n// res32: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MinSize(path = FieldPath(parts = List()), size = 5))\n// )\nstringF.maxSize(1)\n// res33: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MaxSize(path = FieldPath(parts = List()), size = 1))\n// )\nstringF.blank\n// res34: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Empty(path = FieldPath(parts = List())))\n// )\nstringF.matchesRegex("scala".r)\n// res35: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/match",\n//       message = Some(value = "must match scala")\n//     )\n//   )\n// )\nstringF.matches("scala")\n// res36: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Message(\n//       path = FieldPath(parts = List()),\n//       error = "string/match",\n//       message = Some(value = "must match scala")\n//     )\n//   )\n// )\n')),(0,r.kt)("h2",{id:"iterable"},"Iterable"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val listF: Field[List[Int]] = Field(List(1, 12))\n// listF: Field[List[Int]] = Field(path = FieldPath(parts = List()), value = List(1, 12))\nlistF.each(_ > 10)\n// res37: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(Greater(path = FieldPath(parts = List("0")), compared = "10"))\n// )\nlistF.any(_ === 10)\n// res38: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Equal(path = FieldPath(parts = List("1")), compared = "10"),\n//     Equal(path = FieldPath(parts = List("0")), compared = "10")\n//   )\n// )\nField(List()).nonEmpty\n// res39: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List())))\n// )\nlistF.minSize(3)\n// res40: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MinSize(path = FieldPath(parts = List()), size = 3))\n// )\nlistF.maxSize(1)\n// res41: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MaxSize(path = FieldPath(parts = List()), size = 1))\n// )\n')),(0,r.kt)("h2",{id:"map"},"Map"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val mapF: Field[Map[String, Int]] = Field(Map("" -> 2, "2" -> 2))\n// mapF: Field[Map[String, Int]] = Field(\n//   path = FieldPath(parts = List()),\n//   value = Map("" -> 2, "2" -> 2)\n// )\nmapF.minSize(4)\n// res42: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MinSize(path = FieldPath(parts = List()), size = 4))\n// )\nmapF.maxSize(1)\n// res43: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(MaxSize(path = FieldPath(parts = List()), size = 1))\n// )\nmapF.each(_.second > 4)\n// res44: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List("")), compared = "4"),\n//     Greater(path = FieldPath(parts = List("2")), compared = "4")\n//   )\n// )\nmapF.eachKey(_.nonEmpty)\n// res45: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(NonEmpty(path = FieldPath(parts = List(""))))\n// )\nmapF.eachValue(_ > 4)\n// res46: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List("")), compared = "4"),\n//     Greater(path = FieldPath(parts = List("2")), compared = "4")\n//   )\n// )\nmapF.any(_.second > 4)\n// res47: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List("2")), compared = "4"),\n//     Greater(path = FieldPath(parts = List("")), compared = "4")\n//   )\n// )\nmapF.anyKey(_ === "4")\n// res48: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Equal(path = FieldPath(parts = List("2")), compared = "4"),\n//     Equal(path = FieldPath(parts = List("")), compared = "4")\n//   )\n// )\nmapF.anyValue(_ > 4)\n// res49: Rule[Sync, [E >: Nothing <: Any] => Accumulate[E], ValidationError] = Invalid(\n//   errors = List(\n//     Greater(path = FieldPath(parts = List("2")), compared = "4"),\n//     Greater(path = FieldPath(parts = List("")), compared = "4")\n//   )\n// )\n')),(0,r.kt)("h2",{id:"effectful"},"Effectful"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import jap.fields._\nimport jap.fields.ZIOInterop._\nimport jap.fields.fail._\nimport jap.fields.error._\nimport zio._\n\nobject Validation extends AccumulateVM[Task, ValidationError] with CanFailWithValidationError\nimport Validation._\n\ndef unsafeRun[A](task: Task[A]) = Runtime.global.unsafeRun(task)\ndef isPositiveApi(number: Int): zio.Task[Boolean] = zio.UIO(number > 0)\n\nval field = Field(FieldPath("size"), -1)\n// field: Field[Int] = Field(path = FieldPath(parts = List("size")), value = -1)\nunsafeRun(field.ensureF(isPositiveApi, _.failMessage("API: NOT POSITIVE")).effect)\n// res51: Accumulate[ValidationError] = Invalid(\n//   errors = List(\n//     Message(path = FieldPath(parts = List("size")), error = "API: NOT POSITIVE", message = None)\n//   )\n// )\nunsafeRun(field.assertF(isPositiveApi, _.messageError("API: NOT POSITIVE")).effect)\n// res52: Accumulate[ValidationError] = Invalid(\n//   errors = List(\n//     Message(path = FieldPath(parts = List("size")), error = "API: NOT POSITIVE", message = None)\n//   )\n// )\n')))}p.isMDXComponent=!0}}]);